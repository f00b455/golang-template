name: Pipeline Orchestrator

on:
  pull_request:
    types: [opened, synchronize, labeled]
  workflow_run:
    workflows:
      - "Go CI/CD"
      - "Claude Code Review"
      - "Claude Code Improvements"
      - "Claude Iterative Fix"
    types:
      - completed
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull Request number to orchestrate'
        required: true
        type: string

env:
  MAX_ITERATIONS: 5
  COOLDOWN_SECONDS: 30

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.event == 'pull_request' &&
       github.event.workflow_run.name != 'Pipeline Orchestrator')

    permissions:
      contents: read
      pull-requests: write
      actions: write
      checks: read
      statuses: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine PR Number
        id: pr-number
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "PR_NUMBER=${{ inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            # For workflow_run events, get PR from the workflow run
            PR_DATA=$(gh api /repos/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }} --jq '.pull_requests')
            if [[ "$PR_DATA" != "[]" ]]; then
              PR_NUMBER=$(echo "$PR_DATA" | jq -r '.[0].number')
              echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
            else
              echo "No PR associated with workflow run"
              exit 0
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check Pipeline State
        id: state
        run: |
          PR_NUMBER="${{ steps.pr-number.outputs.PR_NUMBER }}"
          echo "üìã Checking pipeline state for PR #$PR_NUMBER"

          # Get current labels
          LABELS=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name' | grep "^pipeline:" || echo "")
          echo "üè∑Ô∏è Current pipeline labels: ${LABELS:-none}"

          # Check for stop signal
          if echo "$LABELS" | grep -q "pipeline:stop"; then
            echo "üõë Pipeline stopped by user"
            echo "SHOULD_CONTINUE=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if another action is already in progress (fixing, reviewing, improving)
          if echo "$LABELS" | grep -qE "pipeline:(fixing|reviewing|improving)"; then
            echo "‚è≥ Another pipeline action is already in progress"
            echo "SHOULD_CONTINUE=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get iteration count from labels
          ITERATION=$(echo "$LABELS" | grep -oP 'pipeline:iteration-\K\d+' || echo "0")
          if [[ -z "$ITERATION" ]]; then
            ITERATION=0
          fi

          echo "CURRENT_ITERATION=$ITERATION" >> $GITHUB_OUTPUT
          echo "üîÑ Current iteration: $ITERATION / ${{ env.MAX_ITERATIONS }}"

          # Check max iterations
          if [[ $ITERATION -ge ${{ env.MAX_ITERATIONS }} ]]; then
            echo "Max iterations reached (${{ env.MAX_ITERATIONS }})"
            echo "SHOULD_CONTINUE=false" >> $GITHUB_OUTPUT

            # Add max iterations reached label
            gh pr edit $PR_NUMBER --add-label "pipeline:max-iterations-reached"

            # Post comment
            gh pr comment $PR_NUMBER --body "## üîÑ Pipeline Status: Max Iterations Reached

            The pipeline has completed **$ITERATION** iterations, reaching the maximum limit.

            ### Next Steps:
            - Review the changes made by the automated pipeline
            - Add label \`pipeline:continue\` to run more iterations
            - Add label \`pipeline:stop\` to stop the pipeline
            - Manually merge if satisfied with the current state"

            exit 0
          fi

          echo "SHOULD_CONTINUE=true" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Next Action
        id: next-action
        if: steps.state.outputs.SHOULD_CONTINUE == 'true'
        run: |
          PR_NUMBER="${{ steps.pr-number.outputs.PR_NUMBER }}"
          WORKFLOW_NAME="${{ github.event.workflow_run.name || github.event.workflow_run.workflow_name || 'Initial' }}"
          WORKFLOW_CONCLUSION="${{ github.event.workflow_run.conclusion || 'none' }}"

          echo "üéØ Workflow Detection:"
          echo "   Triggered by: $WORKFLOW_NAME"
          echo "   Conclusion: $WORKFLOW_CONCLUSION"
          echo "   Event: ${{ github.event_name }}"

          # Remove all pipeline state labels
          gh pr edit $PR_NUMBER --remove-label "pipeline:testing" 2>/dev/null || true
          gh pr edit $PR_NUMBER --remove-label "pipeline:fixing" 2>/dev/null || true
          gh pr edit $PR_NUMBER --remove-label "pipeline:reviewing" 2>/dev/null || true
          gh pr edit $PR_NUMBER --remove-label "pipeline:improving" 2>/dev/null || true
          gh pr edit $PR_NUMBER --remove-label "pipeline:complete" 2>/dev/null || true
          gh pr edit $PR_NUMBER --remove-label "pipeline:fix-attempted" 2>/dev/null || true

          # Determine next action based on workflow that just completed
          case "$WORKFLOW_NAME" in
            "Go CI/CD")
              # Check individual job statuses rather than overall workflow conclusion
              COMMIT_SHA=$(gh pr view $PR_NUMBER --json headRefOid --jq '.headRefOid')

              # Get specific job conclusions
              LINT_STATUS=$(gh api "repos/${{ github.repository }}/commits/$COMMIT_SHA/check-runs" --jq '.check_runs[] | select(.name == "Lint") | .conclusion')
              TEST_STATUS=$(gh api "repos/${{ github.repository }}/commits/$COMMIT_SHA/check-runs" --jq '.check_runs[] | select(.name == "Test") | .conclusion')

              # Check if we've attempted a fix
              HAS_FIX_ATTEMPTED=$(echo "$LABELS" | grep -q "pipeline:fix-attempted" && echo "true" || echo "false")

              echo "üìä Go CI/CD Results:"
              echo "   Lint status: ${LINT_STATUS:-unknown}"
              echo "   Test status: ${TEST_STATUS:-unknown}"
              echo "   Fix attempted: $HAS_FIX_ATTEMPTED"

              if [[ "$LINT_STATUS" == "success" && "$TEST_STATUS" == "success" ]]; then
                # Tests passed! Check if we should trigger review
                if [[ "$HAS_FIX_ATTEMPTED" == "true" ]]; then
                  echo "‚úÖ Decision: Tests passed after fix ‚Üí triggering code review"
                  echo "NEXT_ACTION=review" >> $GITHUB_OUTPUT
                  gh pr edit $PR_NUMBER --add-label "pipeline:reviewing"
                  gh pr edit $PR_NUMBER --remove-label "pipeline:fix-attempted" 2>/dev/null || true
                else
                  echo "‚úÖ Decision: Tests passed (no fixes needed) ‚Üí triggering code review"
                  echo "NEXT_ACTION=review" >> $GITHUB_OUTPUT
                  gh pr edit $PR_NUMBER --add-label "pipeline:reviewing"
                fi
              else
                # Tests failed - check iteration count before triggering fix
                CURRENT_ITERATION="${{ steps.state.outputs.CURRENT_ITERATION }}"
                if [[ $CURRENT_ITERATION -lt ${{ env.MAX_ITERATIONS }} ]]; then
                  echo "üîß Decision: Checks failed ‚Üí triggering iterative fix"
                  echo "   Reason: Lint=${LINT_STATUS:-failed}, Test=${TEST_STATUS:-failed}"
                  echo "NEXT_ACTION=fix" >> $GITHUB_OUTPUT
                  gh pr edit $PR_NUMBER --add-label "pipeline:fixing"
                else
                  echo "üõë Max iterations reached, not triggering more fixes"
                  echo "NEXT_ACTION=none" >> $GITHUB_OUTPUT
                fi
              fi
              ;;

            "Claude Iterative Fix")
              if [[ "$WORKFLOW_CONCLUSION" == "success" ]]; then
                echo "‚úÖ Decision: Fix workflow completed ‚Üí waiting for tests to complete"
                echo "NEXT_ACTION=wait_for_tests" >> $GITHUB_OUTPUT
                # Remove the fixing label since the fix workflow has completed
                gh pr edit $PR_NUMBER --remove-label "pipeline:fixing" 2>/dev/null || true
                gh pr edit $PR_NUMBER --add-label "pipeline:testing"

                # Mark that we've attempted a fix, so we know to review after tests pass
                gh pr edit $PR_NUMBER --add-label "pipeline:fix-attempted"
              else
                echo "‚ùå Fix workflow failed, removing fixing label"
                gh pr edit $PR_NUMBER --remove-label "pipeline:fixing" 2>/dev/null || true
              fi
              ;;

            "Claude Code Review")
              if [[ "$WORKFLOW_CONCLUSION" == "success" ]]; then
                # Check if review had suggestions (look for recent review comments)
                RECENT_REVIEW=$(gh pr view $PR_NUMBER --json comments --jq '.comments[-1].body' 2>/dev/null || echo "")

                if echo "$RECENT_REVIEW" | grep -q "Issues\|Recommendations\|Fix\|Should"; then
                  echo "Review has suggestions, triggering improvements"
                  echo "NEXT_ACTION=improve" >> $GITHUB_OUTPUT
                  gh pr edit $PR_NUMBER --add-label "pipeline:improving"
                else
                  echo "Review complete with no major issues"
                  echo "NEXT_ACTION=complete" >> $GITHUB_OUTPUT
                  gh pr edit $PR_NUMBER --add-label "pipeline:complete"
                fi
              fi
              ;;

            "Claude Code Improvements")
              if [[ "$WORKFLOW_CONCLUSION" == "success" ]]; then
                echo "Improvements applied, re-running tests"
                echo "NEXT_ACTION=test" >> $GITHUB_OUTPUT
                gh pr edit $PR_NUMBER --add-label "pipeline:testing"

                # Increment iteration counter
                CURRENT_ITERATION="${{ steps.state.outputs.CURRENT_ITERATION }}"
                NEXT_ITERATION=$((CURRENT_ITERATION + 1))

                # Remove old iteration label
                gh pr edit $PR_NUMBER --remove-label "pipeline:iteration-$CURRENT_ITERATION" 2>/dev/null || true

                # Add new iteration label
                gh pr edit $PR_NUMBER --add-label "pipeline:iteration-$NEXT_ITERATION"
              fi
              ;;

            "Initial"|"")
              # Initial trigger or manual dispatch
              echo "Starting pipeline with tests"
              echo "NEXT_ACTION=test" >> $GITHUB_OUTPUT
              gh pr edit $PR_NUMBER --add-label "pipeline:testing"
              gh pr edit $PR_NUMBER --add-label "pipeline:iteration-1"
              ;;

            *)
              echo "Unknown workflow: $WORKFLOW_NAME"
              echo "NEXT_ACTION=none" >> $GITHUB_OUTPUT
              ;;
          esac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Add Cooldown
        if: steps.next-action.outputs.NEXT_ACTION != 'none' && steps.next-action.outputs.NEXT_ACTION != 'complete'
        run: |
          echo "Adding ${{ env.COOLDOWN_SECONDS }} second cooldown before next action..."
          sleep ${{ env.COOLDOWN_SECONDS }}

      - name: Trigger Next Action
        if: steps.state.outputs.SHOULD_CONTINUE == 'true'
        run: |
          NEXT_ACTION="${{ steps.next-action.outputs.NEXT_ACTION }}"
          PR_NUMBER="${{ steps.pr-number.outputs.PR_NUMBER }}"

          case "$NEXT_ACTION" in
            "test")
              echo "Tests will run automatically on the next push"
              # Only add a comment if this is the first test run in an iteration
              CURRENT_ITERATION="${{ steps.state.outputs.CURRENT_ITERATION }}"
              if [[ "$CURRENT_ITERATION" -eq "1" ]] || [[ "${{ github.event.workflow_run.name }}" == "Claude Iterative Fix" ]] || [[ "${{ github.event.workflow_run.name }}" == "Claude Code Improvements" ]]; then
                gh pr comment $PR_NUMBER --body "üîÑ **Pipeline Status**: Running tests (iteration $CURRENT_ITERATION)"
              fi
              ;;

            "wait_for_tests")
              echo "‚è≥ Tests are running automatically after the push from Claude Iterative Fix"
              gh pr comment $PR_NUMBER --body "‚è≥ **Pipeline Status**: Waiting for tests to complete after iteration fixes"
              # Tests will trigger automatically, and Pipeline Orchestrator will run again when Go CI/CD completes
              ;;

            "fix")
              echo "Triggering iterative fix workflow..."
              gh workflow run claude-iterative-fix.yml --field pr_number="$PR_NUMBER"
              gh pr comment $PR_NUMBER --body "üîß **Pipeline Status**: Applying automated fixes"
              ;;

            "review")
              echo "Triggering code review workflow..."
              gh workflow run claude-code-review.yml --field pr_number="$PR_NUMBER"
              gh pr comment $PR_NUMBER --body "üìù **Pipeline Status**: Running code review"
              ;;

            "improve")
              echo "Improvements will trigger after review completes"
              gh pr comment $PR_NUMBER --body "‚ú® **Pipeline Status**: Implementing review feedback"
              ;;

            "complete")
              gh pr comment $PR_NUMBER --body "‚úÖ **Pipeline Complete**: All checks passed after ${{ steps.state.outputs.CURRENT_ITERATION }} iteration(s)

              The automated pipeline has successfully completed. The PR is ready for final human review and merge."
              ;;

            *)
              echo "No action to trigger"
              ;;
          esac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Post Status Summary
        if: always()
        run: |
          PR_NUMBER="${{ steps.pr-number.outputs.PR_NUMBER }}"
          ITERATION="${{ steps.state.outputs.CURRENT_ITERATION }}"

          # Get all pipeline labels
          LABELS=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name' | grep "^pipeline:" | paste -sd ", " - || echo "none")

          echo "## Pipeline Orchestrator Summary"
          echo "- PR: #$PR_NUMBER"
          echo "- Iteration: $ITERATION / ${{ env.MAX_ITERATIONS }}"
          echo "- Labels: $LABELS"
          echo "- Next Action: ${{ steps.next-action.outputs.NEXT_ACTION || 'none' }}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}