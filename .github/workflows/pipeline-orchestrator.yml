name: Pipeline Orchestrator

on:
  pull_request:
    types: [opened, synchronize, labeled]
  workflow_run:
    workflows:
      - "Go CI/CD"
      - "Claude Code Review"
      - "Claude Code Improvements"
      - "Claude Iterative Fix"
    types:
      - completed
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull Request number to orchestrate'
        required: true
        type: string

env:
  MAX_ITERATIONS: 5
  COOLDOWN_SECONDS: 30

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.event == 'pull_request' &&
       github.event.workflow_run.name != 'Pipeline Orchestrator')

    permissions:
      contents: read
      pull-requests: write
      actions: write
      checks: read
      statuses: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine PR Number
        id: pr-number
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "PR_NUMBER=${{ inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            # For workflow_run events, get PR from the workflow run
            PR_DATA=$(gh api /repos/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }} --jq '.pull_requests')
            if [[ "$PR_DATA" != "[]" ]]; then
              PR_NUMBER=$(echo "$PR_DATA" | jq -r '.[0].number')
              echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
            else
              echo "No PR associated with workflow run"
              exit 0
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check Pipeline State
        id: state
        run: |
          PR_NUMBER="${{ steps.pr-number.outputs.PR_NUMBER }}"
          echo "📋 Checking pipeline state for PR #$PR_NUMBER"

          # Get current labels
          LABELS=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name' | grep "^pipeline:" || echo "")
          echo "🏷️ Current pipeline labels: ${LABELS:-none}"

          # Check for stop signal
          if echo "$LABELS" | grep -q "pipeline:stop"; then
            echo "🛑 Pipeline stopped by user"
            echo "SHOULD_CONTINUE=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if another action is already in progress (fixing, reviewing, improving)
          if echo "$LABELS" | grep -qE "pipeline:(fixing|reviewing|improving)"; then
            echo "⏳ Another pipeline action is already in progress"
            echo "SHOULD_CONTINUE=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get iteration count from labels
          ITERATION=$(echo "$LABELS" | grep -oP 'pipeline:iteration-\K\d+' || echo "0")
          if [[ -z "$ITERATION" ]]; then
            ITERATION=0
          fi

          echo "CURRENT_ITERATION=$ITERATION" >> $GITHUB_OUTPUT
          echo "🔄 Current iteration: $ITERATION / ${{ env.MAX_ITERATIONS }}"

          # Check max iterations
          if [[ $ITERATION -ge ${{ env.MAX_ITERATIONS }} ]]; then
            echo "Max iterations reached (${{ env.MAX_ITERATIONS }})"
            echo "SHOULD_CONTINUE=false" >> $GITHUB_OUTPUT

            # Add max iterations reached label
            gh pr edit $PR_NUMBER --add-label "pipeline:max-iterations-reached"

            # Post comment
            gh pr comment $PR_NUMBER --body "## 🔄 Pipeline Status: Max Iterations Reached

            The pipeline has completed **$ITERATION** iterations, reaching the maximum limit.

            ### Next Steps:
            - Review the changes made by the automated pipeline
            - Add label \`pipeline:continue\` to run more iterations
            - Add label \`pipeline:stop\` to stop the pipeline
            - Manually merge if satisfied with the current state"

            exit 0
          fi

          echo "SHOULD_CONTINUE=true" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Next Action
        id: next-action
        if: steps.state.outputs.SHOULD_CONTINUE == 'true'
        run: |
          PR_NUMBER="${{ steps.pr-number.outputs.PR_NUMBER }}"
          CURRENT_ITERATION="${{ steps.state.outputs.CURRENT_ITERATION }}"

          echo "🎯 Checking PR #$PR_NUMBER current state..."

          # Get current labels
          LABELS=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name' | grep "^pipeline:" || echo "")

          # Get current commit SHA and check statuses
          COMMIT_SHA=$(gh pr view $PR_NUMBER --json headRefOid --jq '.headRefOid')

          # Get specific job conclusions
          LINT_STATUS=$(gh api "repos/${{ github.repository }}/commits/$COMMIT_SHA/check-runs" --jq '.check_runs[] | select(.name == "Lint") | .conclusion' 2>/dev/null || echo "")
          TEST_STATUS=$(gh api "repos/${{ github.repository }}/commits/$COMMIT_SHA/check-runs" --jq '.check_runs[] | select(.name == "Test") | .conclusion' 2>/dev/null || echo "")

          # Check if we've attempted a fix before
          HAS_FIX_ATTEMPTED=$(echo "$LABELS" | grep -q "pipeline:fix-attempted" && echo "true" || echo "false")

          echo "📊 Current Status:"
          echo "   Lint: ${LINT_STATUS:-not run}"
          echo "   Test: ${TEST_STATUS:-not run}"
          echo "   Iteration: $CURRENT_ITERATION / ${{ env.MAX_ITERATIONS }}"
          echo "   Fix attempted: $HAS_FIX_ATTEMPTED"
          echo "   Labels: ${LABELS:-none}"

          # Clear previous state labels (but keep iteration and fix-attempted)
          gh pr edit $PR_NUMBER --remove-label "pipeline:testing" 2>/dev/null || true
          gh pr edit $PR_NUMBER --remove-label "pipeline:fixing" 2>/dev/null || true
          gh pr edit $PR_NUMBER --remove-label "pipeline:reviewing" 2>/dev/null || true
          gh pr edit $PR_NUMBER --remove-label "pipeline:improving" 2>/dev/null || true
          gh pr edit $PR_NUMBER --remove-label "pipeline:complete" 2>/dev/null || true

          # Decision logic based on actual state
          if [[ -z "$LINT_STATUS" && -z "$TEST_STATUS" ]]; then
            # No tests have run yet
            echo "📝 Decision: No tests found → waiting for initial test run"
            echo "NEXT_ACTION=test" >> $GITHUB_OUTPUT
            gh pr edit $PR_NUMBER --add-label "pipeline:testing"

            # Add iteration label if missing
            if ! echo "$LABELS" | grep -q "pipeline:iteration-"; then
              gh pr edit $PR_NUMBER --add-label "pipeline:iteration-1"
            fi

          elif [[ "${LINT_STATUS,,}" == "success" && "${TEST_STATUS,,}" == "success" ]]; then
            # All checks passed
            if [[ "$HAS_FIX_ATTEMPTED" == "true" ]]; then
              echo "✅ Decision: Tests passed after fix → triggering code review"
              echo "NEXT_ACTION=review" >> $GITHUB_OUTPUT
              gh pr edit $PR_NUMBER --add-label "pipeline:reviewing"
              gh pr edit $PR_NUMBER --remove-label "pipeline:fix-attempted" 2>/dev/null || true
            else
              echo "✅ Decision: Tests passed → triggering code review"
              echo "NEXT_ACTION=review" >> $GITHUB_OUTPUT
              gh pr edit $PR_NUMBER --add-label "pipeline:reviewing"
            fi

          elif [[ "${LINT_STATUS,,}" == "failure" || "${TEST_STATUS,,}" == "failure" ]]; then
            # Tests failed - need to fix
            if [[ $CURRENT_ITERATION -lt ${{ env.MAX_ITERATIONS }} ]]; then
              echo "🔧 Decision: Tests failed → triggering iterative fix"
              echo "   Lint: ${LINT_STATUS:-unknown}, Test: ${TEST_STATUS:-unknown}"
              echo "NEXT_ACTION=fix" >> $GITHUB_OUTPUT
              gh pr edit $PR_NUMBER --add-label "pipeline:fixing"
            else
              echo "🛑 Max iterations reached (${{ env.MAX_ITERATIONS }})"
              echo "NEXT_ACTION=none" >> $GITHUB_OUTPUT
              gh pr edit $PR_NUMBER --add-label "pipeline:max-iterations-reached"
            fi

          elif [[ "${LINT_STATUS,,}" == "in_progress" || "${TEST_STATUS,,}" == "in_progress" || "${LINT_STATUS,,}" == "pending" || "${TEST_STATUS,,}" == "pending" ]]; then
            # Tests are running
            echo "⏳ Decision: Tests in progress → waiting"
            echo "NEXT_ACTION=wait" >> $GITHUB_OUTPUT
            gh pr edit $PR_NUMBER --add-label "pipeline:testing"

          else
            # Unknown state
            echo "❓ Unknown state - waiting for tests"
            echo "NEXT_ACTION=test" >> $GITHUB_OUTPUT
            gh pr edit $PR_NUMBER --add-label "pipeline:testing"
          fi

          # Special handling for completed workflows
          WORKFLOW_NAME="${{ github.event.workflow_run.name || '' }}"
          if [[ "$WORKFLOW_NAME" == "Claude Iterative Fix" && "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            echo "📌 Claude fix completed - marking fix attempted"
            gh pr edit $PR_NUMBER --add-label "pipeline:fix-attempted"
            gh pr edit $PR_NUMBER --remove-label "pipeline:fixing" 2>/dev/null || true
            gh pr edit $PR_NUMBER --add-label "pipeline:testing"
            echo "NEXT_ACTION=wait_for_tests" >> $GITHUB_OUTPUT

          elif [[ "$WORKFLOW_NAME" == "Claude Code Improvements" && "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            echo "📌 Improvements completed - incrementing iteration"
            NEXT_ITERATION=$((CURRENT_ITERATION + 1))
            gh pr edit $PR_NUMBER --remove-label "pipeline:iteration-$CURRENT_ITERATION" 2>/dev/null || true
            gh pr edit $PR_NUMBER --add-label "pipeline:iteration-$NEXT_ITERATION"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Add Cooldown
        if: steps.next-action.outputs.NEXT_ACTION != 'none' && steps.next-action.outputs.NEXT_ACTION != 'complete' && steps.next-action.outputs.NEXT_ACTION != 'wait' && steps.next-action.outputs.NEXT_ACTION != 'wait_for_tests'
        run: |
          echo "Adding ${{ env.COOLDOWN_SECONDS }} second cooldown before next action..."
          sleep ${{ env.COOLDOWN_SECONDS }}

      - name: Trigger Next Action
        if: steps.state.outputs.SHOULD_CONTINUE == 'true'
        run: |
          NEXT_ACTION="${{ steps.next-action.outputs.NEXT_ACTION }}"
          PR_NUMBER="${{ steps.pr-number.outputs.PR_NUMBER }}"

          case "$NEXT_ACTION" in
            "test")
              echo "Tests will run automatically on the next push"
              CURRENT_ITERATION="${{ steps.state.outputs.CURRENT_ITERATION }}"
              gh pr comment $PR_NUMBER --body "🔄 **Pipeline Status**: Running tests (iteration ${CURRENT_ITERATION:-1})"
              ;;

            "wait"|"wait_for_tests")
              echo "⏳ Waiting for tests to complete"
              # Pipeline Orchestrator will run again when tests complete
              ;;

            "fix")
              echo "Triggering iterative fix workflow..."
              gh workflow run claude-iterative-fix.yml --field pr_number="$PR_NUMBER"
              gh pr comment $PR_NUMBER --body "🔧 **Pipeline Status**: Applying automated fixes (iteration ${{ steps.state.outputs.CURRENT_ITERATION }})"
              ;;

            "review")
              echo "Triggering code review workflow..."
              gh workflow run claude-code-review.yml --field pr_number="$PR_NUMBER"
              gh pr comment $PR_NUMBER --body "📝 **Pipeline Status**: Running code review"
              ;;

            "improve")
              echo "Triggering improvements workflow..."
              gh workflow run claude-code-improvements.yml --field pr_number="$PR_NUMBER"
              gh pr comment $PR_NUMBER --body "✨ **Pipeline Status**: Implementing review feedback"
              ;;

            "complete")
              gh pr comment $PR_NUMBER --body "✅ **Pipeline Complete**: All checks passed after ${{ steps.state.outputs.CURRENT_ITERATION }} iteration(s)

              The automated pipeline has successfully completed. The PR is ready for final human review and merge."
              ;;

            *)
              echo "No action to trigger (action: $NEXT_ACTION)"
              ;;
          esac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Post Status Summary
        if: always()
        run: |
          PR_NUMBER="${{ steps.pr-number.outputs.PR_NUMBER }}"
          ITERATION="${{ steps.state.outputs.CURRENT_ITERATION }}"

          # Get all pipeline labels
          LABELS=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name' | grep "^pipeline:" | paste -sd ", " - || echo "none")

          echo "## Pipeline Orchestrator Summary"
          echo "- PR: #$PR_NUMBER"
          echo "- Iteration: $ITERATION / ${{ env.MAX_ITERATIONS }}"
          echo "- Labels: $LABELS"
          echo "- Next Action: ${{ steps.next-action.outputs.NEXT_ACTION || 'none' }}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}